# CarND-Path-Planning-Project-Solution
Solution to the first project of Term 3: CarND Path Planning Project

## Project Description
My solution is based on a Project Walkthrough. I was able to reach 85.58 miles without colliding with other vehicles (see video https://youtu.be/2Mo-DpxiNLk), which is about two hours of driving at an average speed of 42.5 mph and almost 20 times around the track. The following modifications were made to the project presented in the Project Wakthrough:

1. I introduce two Boolean vectors of size 3 each (one Boolean for each lane) for tracking cars that are too close in front and in the rear of the car: too_close_front and too_close_rear. I also have two arrays of size 3 each for tracking the speeds of vehicles that are too close: too_close_front_speed and too_close_rear_speed. Finally there is a vector of size 3 for tracking the distance to the vehicles that are in front and are too close: too_close_front_distance. See lines 308-315.

2. I am using Gaussian Naive Bayes classifier: see my implementation in file classifier.cpp. I calculate s_dot and d_dot values on lines 327-333 of main.cpp, and then for every car in the sensor_fusion array that is either within 30 meters in front or within 30 meters behind my vehicle position (I look at all three lanes) I try to predict the action that the car is going to take ("keep", "left" or "right"). Note, that I train the classifier by using the data from the quiz on lines 216-226 of main.cpp. After I make the prediction I go through all the lanes (see the loop in main.cpp, lines 352-399) and record the lanes that have vehicles too close to the front and rear as well as the speed of those vehicles and the distance from the ego car fro the cars that are in front.

3. I decide to change lanes only if there is a vehicle too close in front of me and there are no vehicles too close to me in both front and rear in the direction of the lane change (see lines 401-423 of main.cpp).

4. The control of the vehicle speed is done on lines 424-433 of main.cpp. If the ego vehicle is too close to the car in front, the ego vehicle will take both the speed and the location of the front car relative to the ego vehicle into consideration when calculating the new relative velocity (see line 428 of main.cpp). We try both to match the speed of the car in front as well as initiate more energetic braking (the second term of the expression) if we get too close to the vehicle. If there are no vehicles too close in front, the ego vehicle will accelerate with acceleration becoming smaller and smaller as we approach the speed limit (line 432 of main.cpp).

5. The actual trajectory generation was not changed from a Project Walkthrough (lines 435-533). Only a single trajectory is generated and followed.

## Discussion
The car drives successfully for 85.58 miles by insuring that there is a sufficient buffer between the ego car and other vehicles when attempting a lane change. The other contributing factor is the prediction module based on Gaussian Naive Bayes Classifier: though the car becomes fairly skittish around other vehicles by quite often suspecting that the vehicle is about to change lanes, this addition ensures that there is sufficient buffer between the ego car and other vehicles. I also observed several times how vehicle avoided collision by proactively changing lanes where the previous version of the program without prediction would have collided with the vehicle in front. Additional features that insured success: rapid acceleration at lower speeds that tapers out as the vehicle approaches the speed limit avoids collisions from the rear of the car. Implementation of two terms when calculating velocity (line 428 of main.cpp) avoids frontal collisions and amounts to functionality similar to Adaptive Cruise Control (first term) and Emergency Braking (second term).